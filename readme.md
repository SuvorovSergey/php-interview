
# Вопросы с собеседований на PHP разработчика

## Содержание
* ### [Junior](#junior-1)
    * [Назовите простые типы данных, поддерживаемые в РНР](#назовите-простые-типы-данных-поддерживаемые-в-рнр)
    * [Что такое ссылки?](#что-такое-ссылки)
    * [Каковы основные операции с использованием ссылок?](#каковы-основные-операции-с-использованием-ссылок)
    * [Что такое инкремент и декремент, в чем разница между префиксным и постфиксным инкрементом и декрементом?](#что-такое-инкремент-и-декремент-в-чем-разница-между-префиксным-и-постфиксным-инкрементом-и-декрементом)
    * [Что такое рекурсия?](#что-такое-рекурсия)
    * [Что такое чистая функция?](#что-такое-чистая-функция)
    * [Что такое функции первого порядка?](#что-такое-функции-первого-порядка)
    * [Что такое иммутабельность?](#что-такое-иммутабельность)
    * [В чем разница между =, == и ===?](#в-чем-разница-между---и-)
    * [Какие знаете принципы ООП?](#какие-знаете-принципы-ооп)
    * [Чем отличаются ключевые слова include и require?](#чем-отличаются-ключевые-слова-include-и-require)
    * [Какие модификаторы видимости есть в РНР?](#какие-модификаторы-видимости-есть-в-рнр)
    * [Что такое интерфейсы?](#что-такое-интерфейсы)
    * [Зачем нужны интерфейсы?](#зачем-нужны-интерфейсы)
    * [Что такое абстрактный класс и чем он отличается от интерфейса?](#что-такое-абстрактный-класс-и-чем-он-отличается-от-интерфейса)
    * [Какие магические методы вы знаете и как их применяют?](#может-ли-абстрактный-класс-содержать-частный-метод)
    * [Что такое генераторы и как их использовать?](#что-такое-генераторы-и-как-их-использовать)
    * [Что такое traits? Альтернативное решение? Приведите пример.](#что-такое-traits-альтернативное-решение-приведите-пример)
    * [Опишите поведение при использовании traits с одинаковыми именами полей или методов.](#опишите-поведение-при-использовании-traits-с-одинаковыми-именами-полей-или-методов)
    * [Будут ли доступны частные методы trait в классе?](#будут-ли-доступны-частные-методы-trait-в-классе)
    * [Можно ли компоновать traits в trait?](#можно-ли-компоновать-traits-в-trait)
    * [Расскажите об обработке ошибок и исключения (try catch, finally и throw)](#расскажите-об-обработке-ошибок-и-исключения-try-catch-finally-и-throw)
    * [Что такое Composer?](#что-такое-composer)
    * [Чем отличается require от require-dev в composer.json?](#чем-отличается-require-от-require-dev-в-composer-json)
    * [Есть ли разница между self и this в PHP](#есть-ли-разница-между-self-и-this-в-php)
    * [Расскажите про ключевое слово static в PHP](#расскажите-про-ключевое-слово-static-в-php)
    * [Что такое замыкание в PHP? Приведите пример.](#Что-такое-замыкание-в-PHP-Приведите-пример)
    * [Что вам известно о шаблонах GoF?](#Что-вам-известно-о-шаблонах-GoF)
* ### [Middle](#middle-1)
    * [Назовите паттерны проектирования, с которыми приходилось работать](#назовите-паттерны-проектирования-с-которыми-приходилось-работать)
    * [Опишите реализацию одного из шаблонов проектирования](#опишите-реализацию-одного-из-шаблонов-проектирования)
    * [Как устроен Singleton и почему его считают антипаттерном](#как-устроен-singleton-и-почему-его-считают-антипаттерном)
    * [Что такое Service Layer и где его следует применять?](#что-такое-service-layer-и-где-его-следует-применять)
    * [Что такое идемпотентность](#что-такое-идемпотентность)
    * [Почему идемпотентность важна](#почему-идемпотентность-важна)
    * [Какие HTTP-методы являются идемпотентными для REST](#какие-HTTP-методы-являются-идемпотентными-для-REST)
    * [Опишите жизненный цикл HTTP-запроса](#опишите-жизненный-цикл-HTTP-запроса)
    * [Какие типы уязвимостей знаете? Как от них защищаться?](#)
    * [Что такое PSR?](#Что-такое-PSR)
    * [Оценка сложности алгоритмов Big O. Какие разновидности сложности алгоритмов бывают?](#оценка-сложности-алгоритмов-Big-O-Какие-разновидности-сложности-алгоритмов-бывают)
    * [Что такое структура данных? Назовите самые распространенные.](#что-такое-структура-данных-назовите-самые-распространенные)
    * [В чем разница между стеком и очередью?](#в-чем-разница-между-стеком-и-очередью)
    * [Что такое рефлексия?](#что-такое-рефлексия)
    * [Что такое GRASP?](#что-такое-grasp)
    * [Что такое TDD?](#что-такое-tdd)
    * [Представим ситуацию, в которой нам нужно вызвать частный метод. Как это сделать?](#Представим-ситуацию-в-которой-нам-нужно-вызвать-частный-метод-Как-это-сделать)
* ### [Senior](#senior-1)
    * [Что такое Copy-on-write?](#что-такое-copy-on-write) 
    * [Что такое CQRS?](#что-такое-cqrs) 
    * [Что такое cohesion и coupling?](#что-такое-cohesion-и-coupling)
    * [Чем отличается Dependency Injection от Service Locator?](#чем-отличается-Dependency-Injection-от-Service-Locator)
    * [Что такое антипаттерны? Приведите несколько примеров?](#что-такое-антипаттерны-Приведите-несколько-примеров)
    * [По какому принципу будете выбирать архитектуру для своей будущей программы?](#по-какому-принципу-будете-выбирать-архитектуру-для-своей-будущей-программы)
    * [С какими видами архитектуры приложений сталкивались?](#С-какими-видами-архитектуры-приложений-сталкивались)
    * [Как вы понимаете Exception flow в контексте PHP](#Как-вы-понимаете-Exception-flow-в-контексте-PHP)


## Junior

## Назовите простые типы данных, поддерживаемые в РНР

Четыре скалярных типа:

```text  
bool  
int  
float  
string  
```  

Четыре смешанных типа:

```text  
array  
object  
callable (Callback-функции могут быть обозначены объявлением типа callable)  
iterable (псевдотип, введённый в PHP 7.1. Он принимает любой массив (array) или объект, реализующий интерфейс Traversable. Оба этих типа итерируются с помощью foreach и могут быть использованы с yield from в генераторах.)  
```  

И два специальных типа:

```text  
resource  
NULL  
```  

**[⬆ вернуться к началу](#содержание)**


## Что такое ссылки?
Ссылки в PHP - это средство доступа к содержимому одной переменной под разными именами. Они не похожи на указатели C; например, вы не можете выполнять над ними адресную арифметику, они не являются реальными адресами в памяти и т.д. Для получения дополнительной информации смотрите Чем ссылки не являются. Вместо этого указатели в PHP - это псевдонимы в таблице имён переменных. В PHP имя переменной и её содержимое - это разные вещи, поэтому одно содержимое может иметь разные имена. Можно провести аналогию с именами файлов и файлами в Unix: имена переменных - записи в каталоге, а содержимое переменной - это сам файл. Ссылки в PHP - аналог жёстких ссылок в файловых системах Unix.

**[⬆ вернуться к началу](#содержание)**


## Каковы основные операции с использованием ссылок?

Есть три основных операции с использованием ссылок: присвоение по ссылке, передача по ссылке и возврат по ссылке.

* Ссылки PHP позволяют создать две переменные указывающие на одно и то же значение.
```php  
$a = &$b;  
```  
> $a и $b здесь абсолютно эквивалентны, но это не означает, что $a указывает на $b или наоборот. Это означает, что $a и $b указывают на одно и то же значение.

* Передача параметров по ссылке. При этом локальная переменная в функции и переменная в вызывающей области видимости ссылаются на одно и то же содержимое.

```php  
function foo(&$var) {  
    $var++;
}

$a = 5; foo($a);  
```  
> Этот код присвоит $a значение 6.

* Возврат по ссылке используется в тех случаях, когда вы хотите использовать функцию для выбора переменной, с которой должна быть связана данная ссылка.

```php  
class foo {  
    public $value = 42;  
  
    public function &getValue() {  
        return $this->value;  
    }  
}  

$obj = new foo;  
$myValue = &$obj->getValue(); // $myValue указывает на $obj->value, равное 42.  
$obj->value = 2;  
echo $myValue;                // отобразит новое значение $obj->value, то есть 2.  
```

**[⬆ вернуться к началу](#содержание)**



## Что такое инкремент и декремент, в чем разница между префиксным и постфиксным инкрементом и декрементом?

Это унарные операции, они увеличивают или уменьшают на единицу число, записанное в переменную и возвращают переменную.  
При использовании префиксной нотации сначала происходит изменение переменной, а потом возврат.  
При использовании постфиксной нотации — наоборот: сначала возврат, а потом изменение переменной.  

```php  
$x = 5;  
  
echo ++$x; // => 6  
echo $x;   // => 6  
  
echo $x++; // => 6  
echo $x;   // => 7  
```

**[⬆ вернуться к началу](#содержание)**

## Что такое рекурсия?
В применении к программированию это значит написание такого алгоритма функции, в котором функция будет вызывать сама себя.

В более сложном случае функция может вызывать другую функцию, которая будет вызывать исходную функцию.

Используя рекурсию, нужно понимать её опасность: ресурсы компьютера не безграничны, и если глубина рекурсии будет достаточно большой (или вообще бесконечной), то это приведет к переполнению стека.

```php  
// функция будет бесконечно вызывать саму себя  
function foo() {  
    return foo();
}  
  
foo();  
```

Пример вычисления факториала с использованием рекурсии

```php  
function factorial($n) {  
    if ($n <= 1) { 
        return 1; 
    }
        
    return $n * factorial($n - 1); 
}
   
echo factorial(5); // 120   
```

**[⬆ вернуться к началу](#содержание)**

## Что такое чистая функция?
Чистая функция — это такая функция которая зависит только от своих аргументов, всегда возвращает одинаковый результат для одних и тех же аргументов и не имеет побочных эффектов (не меняет значения переменных за пределами себя).

```php  
date('Y'); // функция не является чистой, так как возвращаемое значение будет другим в следующем году  
rand(); // еще один пример функции, не являющейся чистой  
mkdir('dirname'); // функция не является чистой, так как возвращаемые значения могут быть разными (true/false)  
max([3, 5, 8]); // чистая функция  
```  
**[⬆ вернуться к началу](#содержание)**


## Что такое функции первого порядка?
Это такие функции, которые могут принимать другие функции, как аргументы, или возвращать функцию.
```php  
function higherOrderFunction(callable $func) {  
    $func();
}  
```  

array_filter функция высшего порядка

```php  
$arrayOfNums = [1,2,3,4,5];  
  
function isEven($num) {  
    return ($num % 2) === 0;
}  
  
$evenNums = array_filter($arrayOfNums, 'isEven');  
  
var_dump($evenNums); // Выводит массив четных чисел [2, 4]  
```

**[⬆ вернуться к началу](#содержание)**

## Что такое иммутабельность?
Иммутабельность это неизменяемость. В применении к объектам можно сказать, что объект иммутабельный, если его состояние нельзя изменить после создания.

**[⬆ вернуться к началу](#содержание)**

## В чем разница между =, == и ===?
= это оператор присваивания. Означает, что левый операнд получает значение правого выражения.

Результатом выполнения оператора присваивания является само присвоенное значение. Это позволяет делать трюки наподобие:

```php  
$a = ($b = 4) + 5; // $a теперь равно 9, а $b было присвоено 4.  
```  

== и === это операторы сравнения.

$a == $b   Равно  true если $a равно $b после преобразования типов.

$a === $b  Тождественно равно true если $a равно $b и имеет тот же тип.

Подробнее о преобразовании типов https://www.php.net/manual/ru/language.operators.comparison.php

**[⬆ вернуться к началу](#содержание)**


## Какие знаете принципы ООП?
  Инкапсуляция, наследование, полиморфизм, абстракция.

**Инкапсуляция** — размещение в одном компоненте данных и методов, которые с ними работают. Также в языках реализующих инкапсуляцию есть механизм сокрытия, позволяющий разграничивать доступ к различным компонентам программы. В php обеспечивается модификаторами доступа.

**Наследование** — способность объекта или класса базироваться на другом объекте или классе. Это главный механизм для повторного использования кода. Объект-потомок автоматически наследует от родителя все поля и методы, может дополнять объекты новыми полями и заменять (перекрывать) методы родителя или дополнять их.

**Полиморфизм** — одно из определений звучит так: Термин “полиморфизм” обозначает семейство различных механизмов, позволяющих использовать один и тот же участок программы с различными типами в различных контекстах.  
Если сказать несколько иначе, это взаимозаменяемость объектов реализующих один интерфейс. Т.е. способность одного и того же участка кода работать с разными типами.

**Абстракция** — отделение концепции от ее экземпляра.

**[⬆ вернуться к началу](#содержание)**

## Чем отличаются ключевые слова include и require?
Оба выражения используются для помещения данных одного файла PHP в другой. Разница в том как они обрабатывают ошибку. Если возникает ошибка, то include генерирует предупреждение, но скрипт продолжит выполнение. Require генерирует фатальную ошибку и выполнение скрипта останавливается.

**[⬆ вернуться к началу](#содержание)**

## Какие модификаторы видимости есть в РНР?
**public** - свойства или методы, объявленные как public, могут быть доступны в любом месте.

**protected** - свойства или методы доступны только внутри класса, а также в дочерних классах.

**private** - доступ к private свойствам и методам имеет только класс, в котором эти свойства или методы объявлены.

Если модификатор доступа не указан, то он будет считаться как public.

**[⬆ вернуться к началу](#содержание)**


## Что такое интерфейсы?
Интерфейс нужно рассматривать как контракт. Он содержит только сигнатуры методов (без тела метода). Класс, реализующий этот контракт, обязан реализовать все методы интерфейса.

Интерфейсы объявляются так же, как и обычные классы, но с использованием ключевого слова interface вместо class. Тела методов интерфейсов должны быть пустыми.  
Все методы, объявленные в интерфейсах, должны быть общедоступными, что следует из самой природы интерфейса.

Для реализации интерфейса используется оператор implements. Класс должен реализовать все методы, описанные в интерфейсе, иначе произойдёт фатальная ошибка. При желании классы могут реализовывать более одного интерфейса, разделяя каждый интерфейс запятой.

>**Интерфейсы не могут содержать объявление статических методов**

>Абстрактный класс может реализовывать **только часть интерфейса**.

>**Интерфейсы могут быть унаследованы друг от друга**, так же как и классы, с помощью оператора extends.

>**Интерфейсы могут содержать константы.** Константы интерфейсов работают точно так же, как и константы классов. До PHP 8.1.0 они не могли быть переопределены классом или интерфейсом, который их наследует.

Пример

```php  
interface A  
{  
    public function foo();
}  
  
interface B extends A  
{  
    public function bar();
}  
  
interface C extends A, B  
{  
    public function baz();
}  
  
class D implements C  
{  
    public function foo() { }  
    public function bar() { }  
    public function baz() { }
}  
```  

Интерфейс с константами

```php  
interface A  
{  
    const B = 'Константа интерфейса';
}  
  
// Выведет: Константа интерфейса  
echo A::B;  
  
class B implements A  
{  
    const B = 'Константа класса';
}  
  
// Выведет: Константа класса  
// До PHP 8.1.0 этот код не будет работать,  
// потому что было нельзя переопределять константы.  
echo B::B;  
```  

**[⬆ вернуться к началу](#содержание)**

## Зачем нужны интерфейсы?
Интерфейс, совместно с объявлениями типов, предоставляет отличный способ проверки того, что определённый объект содержит определённый набор методов.

Интерфейсы нужны:
* Чтобы позволить разработчикам создавать объекты разных классов, которые могут использоваться взаимозаменяемо, поскольку они реализуют один и тот же интерфейс или интерфейсы. Типичный пример - несколько служб доступа к базе данных, несколько платёжных шлюзов или разных стратегий кеширования. Различные реализации могут быть заменены без каких-либо изменений в коде, который их использует.
* Чтобы разрешить функции или методу принимать и оперировать параметром, который соответствует интерфейсу, не заботясь о том, что ещё может делать объект или как он реализован. Эти интерфейсы часто называют Iterable, Cacheable, Renderable и так далее, чтобы описать их поведение.

**[⬆ вернуться к началу](#содержание)**

## Что такое абстрактный класс и чем он отличается от интерфейса?
Абстрактные классы в php реализуются добавлением ключевого слово abstract.

Абстрактный класс создается только для как элемент иерархии наследования. Это означает, что вы не можете создать объект абстрактного класса.

Дочерний класс, который наследует абстрактный класс, должен реализовывать методы, объявленные абстрактными в родительском классе.

Абстрактный класс хорош, когда есть некоторые общие черты, которые должны быть общими для всех объектов.

Свойства абстрактного класса не могут быть abstract.

| Интерфейс                                                                | Абстрактный класс                                                       |
|--------------------------------------------------------------------------|-------------------------------------------------------------------------|
| Поддерживает множественное наследование                                  | Не поддерживает множественное наследование                              |
| Не содержит конструктор                                                  | Может содержать конструктор                                             |
| Содержит только объявление методов (сигнатуры методов)                   | Может содержать как сигнатуры методов так и их реализации               |
| Не может иметь модификаторов доступа - все методы по умолчанию публичные | Может иметь модификаторы доступа                                        |
| Методы не могут быть статическими                                        | Только методы, содержащие реализацию, могут быть объявлены статическими |

**[⬆ вернуться к началу](#содержание)**

## Может ли абстрактный класс содержать частный метод?
**Абстрактные методы** должны иметь модификаторы либо public, либо protected. Язык не запрещает **абстрактному классу** содержать private методы, но в дочерних классах они будут недоступны.

**[⬆ вернуться к началу](#содержание)**

## Какие магические методы вы знаете и как их применяют?
Магические методы - это специальные методы, которые переопределяют действие PHP по умолчанию, когда над объектом выполняются определённые действия.  
Магические методы вызываются автоматически. Лучший пример это метод __construct(), вызываемый автоматически при создании объекта.

Список магических методов

* __construct() конструктор, вызывается при создании экземпляра объекта
* __destruct() деструктор, вызывается при уничтожении объекта
* __call() запускается при вызове недоступных методов в контексте объекта
* __callStatic() запускается при вызове недоступных методов в статическом контексте
* __get() вызывается в случае, если код пытается считать данные из несуществующих или недоступных свойств объекта
* __set() вызывается при попытке присвоить данные недоступным или несуществующим свойствам объекта
* __isset() будет выполнен при использовании isset() или empty() на недоступных (защищённых или приватных) или несуществующих свойствах
* __unset() будет выполнен при вызове unset() на недоступном (защищённом или приватном) или несуществующем свойстве
* __sleep() вызывается во время обращения к объекту с помощью функции serialize(). В случае очень большого объекта требуется сохранить лишь выбранные свойства во время сериализации и после этого закрыть объект. Метод __sleep() в таком случае возвращает массив с именами всех свойств объекта, которые должны быть сериализированы (преобразованы в специальную строку).
* __wakeup() используется для восстановления связей с объектами и выполнения заданий после того, как передача данных (сериализация) закончена и для объекта вызывается функция unserialize()
* __toString() позволяет классу решать, как он должен реагировать при преобразовании в строку. Например, что вывести при выполнении echo $obj;
* __invoke() вызывается, когда скрипт пытается выполнить объект как функцию
* __set_state() используется в связке с функцией var_export(). Данная функция выводит структурированную информацию о переменной. Если вы используете функцию var_export() для экспорта класса, вам необходимо определить в нем метод __set_state()
* __clone() при клонировании объекта, PHP выполняет поверхностную копию всех свойств объекта. Любые свойства, являющиеся ссылками на другие переменные, останутся ссылками. После завершения клонирования, если метод __clone() определён, то будет вызван метод __clone() вновь созданного объекта для возможного изменения всех необходимых свойств
* __debugInfo() Этот метод вызывается функцией var_dump(), когда необходимо вывести список свойств объекта. Если этот метод не определён, тогда будут выведены все свойства объекта c модификаторами public, protected и private

**[⬆ вернуться к началу](#содержание)**

## Что такое генераторы и как их использовать?
Генераторы предоставляют лёгкий способ реализации простых итераторов без использования дополнительных ресурсов.

Генератор позволяет писать код, использующий foreach для перебора набора данных без необходимости создания массива в памяти, что может привести к превышению лимита памяти, либо потребует довольно много времени для его создания. Вместо этого, вы можете написать функцию-генератор, которая, по сути, является обычной функцией, за исключением того, что вместо возврата единственного значения, генератор может возвращать (yield) столько раз, сколько необходимо для генерации значений, позволяющих перебрать исходный набор данных.

Пример:
```php
function someFunc() 
{
    foreach (range(0, 1000000) as $value) {
        echo $value;
    }
}
someFunc(); // Fatal error: Allowed memory size of 134217728 bytes exhausted
```
Закончилась память!

Так же функция с генератором будет работать:

```php
function someFunc()
{
    foreach (range(0, 1000000) as $value){
        yield $value;
    }
}

var_dump(someFunc()); // object(Generator)[1]
foreach (someFunc() as $value){
    echo $value;
}
```
Генератор - функция с хранимым состоянием. Генератор выполняется до следующего слова yield в коде, где выбрасывает рассчитанное значение значение наружу и "засыпает", ожидая следующего вызова, чтобы потом продолжить с прерванной точки. С помощью генератора можно реализовать поддержку эффективных по памяти бесконечных последовательностей, по типу ряда Фибоначчи или гармонических рядов.
Генераторы могут пригодиться когда необходимо обработать большие объемы данных (например, файлы логов), выполнить вычисления на больших выборках из базы и т.д. И мы не хотим, чтобы эти операции занимали всю доступную память. Использование слова return в генераторе полностью останавливает его, после чего генератор нельзя уже будет пробудить повторно.


```php
function someFunc()
{
    foreach (range(0, 1000000) as $value){
        $signal = yield $value;
        if ($signal === 'stop') {
            return;
        }
    }
}

$generator = someFunc();
foreach($generator as $range) {
    if ($range === 100) { 
        $generator->send('stop');
    } 
}
```

Функции-генераторы могут содержать несколько yield

```php
function exampleGenerator() {
    yield 1;
    yield 2;
    yield 3;
}
 
$generator = exampleGenerator();
foreach ($generator as $value) {
    echo $value;
}
// Выведет: 123
```

**[⬆ вернуться к началу](#содержание)** 


### Что такое traits? Альтернативное решение? Приведите пример.
Трейт - это механизм обеспечения повторного использования кода в языках с поддержкой только одиночного наследования, таких как PHP.
Наследуемый член из базового класса переопределяется членом, находящимся в трейте. Порядок приоритета следующий: члены из текущего класса переопределяют методы в трейте, которые в свою очередь переопределяют унаследованные методы.
В трейтах можно определять статические переменные, статические методы и статические свойства.

**[⬆ вернуться к началу](#содержание)**

### Опишите поведение при использовании traits с одинаковыми именами полей или методов.

Если два трейта добавляют метод с одним и тем же именем, это приводит к фатальной ошибке в случае, если конфликт явно не разрешён.

Для разрешения конфликтов именования между трейтами, используемыми в одном и том же классе, необходимо использовать оператор insteadof для того, чтобы точно выбрать один из конфликтующих методов.

**[⬆ вернуться к началу](#содержание)**

### Будут ли доступны частные методы trait в классе?
Будут. Пример:
```php
trait helloTrait
{
    private function sayHello()
    {
        echo "Hello from trait";
    }
}

class myClass
{
    use helloTrait;

    public function hello()
    {
        $this->sayHello();
    }
}

$obj = new myClass();
$obj->hello(); // Hello from trait
```

**[⬆ вернуться к началу](#содержание)**

### Можно ли компоновать traits в trait?
Трейты могут использоваться и в других трейтах. Используя один или более трейтов в определении другого трейта, он может частично или полностью состоять из членов, определённых в этих трейтах.

**[⬆ вернуться к началу](#содержание)**


### Расскажите об обработке ошибок и исключения (try catch, finally и throw).
В php можно сгенерировать исключение с помощью ключевого слова throw, а также можно перехватить исключение с помощью блока catch. Код генерирующий исключение, должен быть окружён блоком try.
Каждый блок try должен иметь как минимум один соответствующий ему блок catch или finally.
```php
try {
    // какой-то код, который может сгенерировать исключение
} catch (Exception $e) {
    // обработка исключения
}
```
Можно использовать несколько блоков catch, перехватывающих различные классы исключений.

Блок finally также можно использовать после или вместо блока catch. Код в блоке finally всегда будет выполняться после кода в блоках try и catch, независимо от того, было ли выброшено исключение, перед тем как продолжится нормальное выполнение кода.

Одно важное взаимодействие происходит между блоком finally и оператором return. Если оператор return встречается внутри блоков try или catch, блок finally всё равно будет выполнен. Кроме того, оператор return выполняется, когда встречается, но результат будет возвращён после выполнения блока finally. Если блок finally также содержит оператор return, возвращается значение, указанное в блоке finally.

**[⬆ вернуться к началу](#содержание)**

### Что такое Composer?
Composer это менеджер для управления зависимостями PHP-приложения. Композер работает из интерфейса командной строки. Список зависимостей которые нужно установить указывается в файле composer.json. Композер также генерирует файл блокировки composer.lock в котором содержится текущий список установленных зависимостей и их версии.
При запуске composer install происходит установка пакетов указанных в composer.lock. Таким образом все разработчики на проекте имеют одинаковые версии пакетов.
Также composer генерирует файл автозагрузки.

**[⬆ вернуться к началу](#содержание)**

### Чем отличается require от require-dev в composer.json?
В секции require-dev описываются пакеты, которые нужны только для разработки. В проде эти пакеты не понадобятся.

```text
composer install --no-dev
```
Этой командой будут установлены только пакеты описанные в секции require.

**[⬆ вернуться к началу](#содержание)**

### Есть ли разница между self и this в PHP?
Ключевое слово **self** в PHP всегда значит «имя класса, где это слово написано». 
**Self** используется только для обращения к статическим методам и свойствам класса с использованием оператора разрешения области видимости **::** 

Псевдопеременная $this содержит ссылку на текущий объект. Т.е. должен быть создан экземпляр класса. 

**[⬆ вернуться к началу](#содержание)**

### Расскажите про ключевое слово static в PHP.
Ключевое слово **static** в PHP имеет три различных значения.
1. Статическая локальная переменная
2. Статические свойства и методы классов
3. Позднее статическое связывание (LSB - Late Static Binding)


```php
function counter() 
{
  // Статическая локальная переменная.
  // Присваивание выполняется только один раз. Значение сохраняется после окончания работы функции.
  static $i = 0;  
  echo $i;
  $i++;
}

counter(); // 0
counter(); // 1
counter(); // 2
```


```php
class A 
{
    //статическое свойство
    public static $h = 'hello';

    //статический метод
    public static function test(): integer
    {
      return 1;
    }
}

echo A::$h; // 'hello'
echo A::test(); // 1
```


```php
class Junior 
{
    public static $salary = 2000;
    
    public static function getSalary() 
    {
        // Позднее статическое связывание.
        // В рантайме вместо static будет подставляться имя класса в котором происходит вызов
        return static::$salary; 
    }
}

class Middle extends Junior 
{
    public static $salary = 3000;
}

echo Middle::getSalary(); // 3000
```

**[⬆ вернуться к началу](#содержание)**

### Что такое замыкание в PHP? Приведите пример.
Замыкание (closure) в PHP - это анонимная функция, которая может быть сохранена в переменной и передана как аргумент другой функции. Она может иметь доступ к переменным внешней функции, даже после того, как эта функция завершила свою работу.

https://www.php.net/manual/ru/functions.anonymous.php
https://www.php.net/manual/ru/class.closure.php

```php

function multiplyBy($num)
{
  return function ($x) use ($num) {
    return $x * $num;
  };
}

$double = multiplyBy(2);
$triple = multiplyBy(3);

echo $double(5); // результат: 10
echo $triple(5); // результат: 15
```


**[⬆ вернуться к началу](#содержание)**


### Что вам известно о шаблонах GoF?

Шаблоны GoF (Gang of Four) - это набор из 23 стандартных шаблонов проектирования, который был описан в книге "Design Patterns: Elements of Reusable Object-Oriented Software" («Приемы объектно-ориентированного проектирования. Паттерны проектирования») авторов Эриха Гаммы, Ричарда Хелма, Ральфа Джонсона и Джона Влиссидеса.

1) Порождающие шаблоны:

Абстрактная фабрика (Abstract Factory)

Строитель (Builder)

Фабричный метод (Factory Method)

Прототип (Prototype)

Синглтон (Singleton)

2) Структурные шаблоны:

Адаптер (Adapter)

Мост (Bridge)

Компоновщик (Composite)

Декоратор (Decorator)

Фасад (Facade)

Легковес (Flyweight)

Заместитель (Proxy)

3) Поведенческие шаблоны:

Цепочка обязанностей (Chain of Responsibility)

Команда (Command)

Итератор (Iterator)

Посредник (Mediator)

Хранитель (Memento)

Наблюдатель (Observer)

Состояние (State)

Стратегия (Strategy)

Шаблонный метод (Template Method)

Посетитель (Visitor)

Интерпретатор (Interpreter)


Эти три категории шаблонов соответствуют трем основным аспектам проектирования программ: создание объектов, связывание объектов в более крупные структуры и управление взаимодействием между объектами. Каждый шаблон может использоваться для решения типовых задач в каждой из этих трех категорий.

**[⬆ вернуться к началу](#содержание)**


## Middle

### Назовите паттерны проектирования, с которыми приходилось работать
Освежить знания по шаблонам проектирования можно на http://refactoring.guru

**[⬆ вернуться к началу](#содержание)**

### Опишите реализацию одного из шаблонов проектирования.
**[⬆ вернуться к началу](#содержание)**

### Как устроен Singleton и почему его считают антипаттерном?
Singleton - это порождающий паттерн проектирования, который гарантирует, что у класса есть только один экземпляр, и предоставляет к нему глобальную точку доступа.

Общая идея заключается в том, что класс имеет приватный конструктор, который предотвращает создание дополнительных экземпляров, и статический метод, который создает объект при первом вызове и возвращает его при последующих вызовах.
 Обычно этот метод называется GetInstance()

Singleton считается антипаттерном по нескольким причинам:

1. Он нарушает принцип единственной ответственности, так как класс должен быть ответственным только за одну задачу, а Singleton выполняет две: создание объекта и управление доступом к нему.

2. Singleton затрудняет тестирование и может привести к проблемам с зависимостями, так как его использование приводит к жесткой связанности между классами.

3. Singleton может привести к неожиданным проблемам в многопоточной среде, если не синхронизировать доступ к его экземпляру.

4. Singleton может привести к увеличению сложности кода и усложнению его понимания.

Несмотря на это, Singleton используется в определенных случаях, например, когда нужно обеспечить наличие только одного экземпляра объекта базы данных или настройки приложения.

**[⬆ вернуться к началу](#содержание)**

### Что такое Service Layer и где его следует применять?
Паттерн Сервисный слой (Service Layer) определяет для приложения границу и набор допустимых операций с точки зрения взаимодействующих с ним клиентских. 
Он инкапсулирует бизнес-логику приложения, управляя транзакциями и управляя ответами в реализации этих операций.

Другими словами вы пишете логику приложения в классах-сервисах, а в своих контроллерах обращаетесь к ним.

Сервисный слой может быть применен для того чтобы убрать бизнес-логику из контроллера, освободив контроллер от лишних обязанностей,
соблюдая принцип единственной ответственности. Или если есть потребность скомпоновать некую часть логики, 
которая будет использоваться в разных контроллерах. 
Например, логику отправки уведомлений удобнее инкапсулировать в сервис NotificationService и использовать его где необходимо.

Сервисный слой можно использовать в качестве концентратора запросов, если он стоит поверх паттерна Repository и использует паттерн Query object. 
Дело в том, что паттерн Repository ограничивает свой интерфейс посредством интерфейса Query Object. 
А так как класс не должен делать предположений о своих клиентах, то накапливать предустановленные запросы в классе 
Repository нельзя, ибо он не может владеть потребностями всех клиентов. Клиенты должны сами заботиться о себе. 
А сервисный слой как раз и создан для обслуживания клиентов.


```php
namespace App\Http\Controllers;

use App\Http\Requests\CreateOrderRequest;
use App\Services\NotificationService;
use App\Services\OrderService;

class OrderController
{
    private NotificationService $notificationService;
    private OrderService $orderService;
    
    public function __construct(OrderService $orderService, NotificationService $notificationService)
    {
        $this->orderService = $orderService;
        $this->notificationService = $notificationService;
    }

    public function createOrder(CreateOrderRequest $request)
    {
        // Логика создания заказа...
        
        $this->notificationService->notify('order_created', [
            'order' => $order
        ]);
    }
}

```


**[⬆ вернуться к началу](#содержание)**

### Что такое идемпотентность?
**Идемпотентность** это свойство операции, которое проявляется в том, что повторное выполнение операции дает тот же результат, что и первое.
Другими словами, многократное повторение операции эквивалентно однократному.

>Термин образован от латинских слов idem («тот же самый») и potens («способный»).

>Например, умножение на 1 это идемпотентная операция.

> Метод HTTP является идемпотентным, если повторный идентичный запрос, сделанный один или несколько раз подряд, имеет один и тот же эффект, не изменяющий состояние сервера. Другими словами, идемпотентный метод не должен иметь никаких побочных эффектов.

**[⬆ вернуться к началу](#содержание)**

### Почему идемпотентность важна?
Идемпотентность позволяет строить более надежные системы.
> Например, вы пишете bash-скрипт, запускаете его, но через какое-то время он завершается из-за ошибки.
> Вы фиксите ошибку в системе и снова запускаете скрипт. 
> Но часть шагов вашего скрипта падает с ошибкой, так как эти шаги уже были выполнены при первом запуске.

> Чтобы создавать отказоустойчивые системы, нужно выполнять идемпотентные операции.
> 
> Например, указание флага -p гарантирует отсутствие ошибки при запуске mkdir, если директория уже существует.
> 
> ```mkdir -p mydir```
> 
> Использование флага -f укажет команде rm игнорировать несуществующие файлы
> 
> ```rm -f example.txt```
> 


**[⬆ вернуться к началу](#содержание)**


### Какие HTTP-методы являются идемпотентными для REST?
HTTP-методы могут быть идемпотентными или нет. 

Идемпотентные методы ***при повторных вызовах*** не изменяют состояние сервера.  

**Важно понимать, что идемпотентность не гарантируется веб сервером. 
Некоторые приложения могут нарушать эти ограничения.**

> GET — идемпотентный метод. Этим методом просто получают ресурс. 
> Можно вызывать сколько угодно раз - результат всегда будет одинаковым.

> PUT - идемпотентный метод. 

> HEAD - идемпотентный метод.

> OPTIONS - идемпотентный метод.

> TRACE - идемпотентный метод. 

> DELETE — идемпотентный метод. Многократный вызов DELETE /article/3 даст тот же результат, что и первый.
> Даже если код ответа будет отличаться. Например, первый вызов вернет 200, а повторные 404.
> Состояние сервера не изменяется. 

> POST не идемпотентный. Если вызвать POST /article/add несколько раз, то будет создано несколько записей.
   

**[⬆ вернуться к началу](#содержание)**

### Опишите жизненный цикл HTTP-запроса.
**[⬆ вернуться к началу](#содержание)**

### Какие типы уязвимостей знаете? Как от них защищаться?
**[⬆ вернуться к началу](#содержание)**

### Что такое PSR?

PSR (PHP Standards Recommendations) — это набор рекомендаций по программированию на языке PHP. Основное назначение — предоставить проверенные общие концепции, чтобы сделать разработку простой и удобной, повысить надежность и работоспособность продуктов

Стандарты PSR поделены на части. Каждый содержит информацию о том, как нужно выполнять задачи. Например, ставить переносы строк, называть переменные, реализовывать автозагрузку. За каждую часть отвечает свой стандарт. Каждый начинается с аббревиатуры PSR, после которой идет номер. Например, PSR-1 или PSR-4.


**[⬆ вернуться к началу](#содержание)**

### Оценка сложности алгоритмов Big O. Какие разновидности сложности алгоритмов бывают?

Оценка сложности алгоритмов Big O - это способ измерения количества операций, которые выполняет алгоритм, в зависимости от размера входных данных. Она позволяет определить, насколько быстро или медленно работает алгоритм.

Разновидности сложности алгоритмов:

1. O(1) - константная сложность, когда количество операций не зависит от размера входных данных.
2. O(log n) - логарифмическая сложность, когда количество операций растет медленнее, чем размер входных данных.
3. O(n) - линейная сложность, когда количество операций растет пропорционально размеру входных данных.
4. O(n log n) - сложность, которая растет быстрее, чем линейная, но медленнее, чем квадратичная.
5. O(n^2) - квадратичная сложность, когда количество операций растет пропорционально квадрату размера входных данных.
6. O(2^n) - экспоненциальная сложность, когда количество операций растет экспоненциально от размера входных данных.

Чем меньше сложность алгоритма, тем быстрее он работает и меньше затрачивает ресурсов. Поэтому при проектировании программного обеспечения важно учитывать сложность алгоритмов и выбирать наиболее эффективные из них.

**[⬆ вернуться к началу](#содержание)**

### Что такое структура данных? Назовите самые распространенные.

Структура данных - это способ организации и хранения данных в компьютерной программе или системе. Наиболее распространенные структуры данных включают:

1. Массивы - упорядоченные наборы данных одного типа, которые могут быть доступны по индексу.

2. Списки - упорядоченные наборы данных, которые могут содержать элементы разных типов и имеют гибкую длину.

3. Стеки - упорядоченные наборы данных, которые могут быть доступны только с одного конца и работают по принципу "последний пришел - первый ушел".

4. Очереди - упорядоченные наборы данных, которые могут быть доступны только с двух концов и работают по принципу "первый пришел - первый ушел".

5. Деревья - структуры данных, которые состоят из узлов и связей между ними, образующих иерархическую структуру.

6. Графы - структуры данных, которые состоят из вершин и ребер между ними, образующих сеть связей.

7. Хеш-таблицы - структуры данных, которые используют хеш-функции для быстрого поиска и доступа к данным по ключу.

8. Строки - упорядоченные наборы символов, которые могут быть обработаны как единое целое.

**[⬆ вернуться к началу](#содержание)**


### В чем разница между стеком и очередью?
Стек и очередь - это две разные структуры данных, которые используются для хранения и управления элементами.

Стек - это структура данных, в которой элементы добавляются и удаляются только с одного конца, называемого вершиной стека. Элементы, добавленные последними, будут удалены первыми (принцип LIFO - last in, first out). Примером стека может служить стопка тарелок, где верхняя тарелка является последней добавленной и будет первой, которая будет взята.

Очередь - это структура данных, в которой элементы добавляются в один конец и удаляются из другого конца. Элементы, добавленные раньше, будут удалены первыми (принцип FIFO - first in, first out). Примером очереди может служить очередь в кассу или на почте, где первый пришедший будет обслужен первым.

Таким образом, основная разница между стеком и очередью заключается в порядке добавления и удаления элементов. В стеке элементы удаляются в обратном порядке, чем они были добавлены, а в очереди элементы удаляются в том же порядке, что и были добавлены.

**[⬆ вернуться к началу](#содержание)**

### Что такое рефлексия?

В программировании рефлексия означает способность программы анализировать и модифицировать свою структуру и поведение во время выполнения. Это позволяет написать более гибкий и динамический код, который может адаптироваться к различным условиям. Например, с помощью рефлексии можно получить список методов и свойств объекта, создать новый объект класса, вызвать его методы или изменить значения свойств.

**[⬆ вернуться к началу](#содержание)**

### Что такое GRASP?
**GRASP** - General Responsibility Assignment Software Principles - общие принципы распределения обязанностей.
Это набор принципов, которые помогают правильно выбрать объект или модуль для помещения в него определенной обязанности.

Принципы сформулированы в 1997 году Крэгом Ларманом в книге "Applying UML and Patterns" («Применение UML 2.0 и шаблонов проектирования»).

Всего 9 принципов: 5 основных и 4 дополнительных.

>Information Expert (информационный эксперт)
> 
>Creator (создатель)
> 
>Controller (контроллер)
> 
>Low Coupling (слабая связанность)
> 
>High Cohesion (высокое зацепление)


>Pure Fabrication (чистая выдумка)
> 
>Indirection (посредник)
> 
>Polymorphism (полиморфизм)
> 
>Protected Variations (устойчивость к изменениям)

GRASP паттерны не имеют четкой структуры, это лишь обобщенные подходы, принципы, рекомендации, используемые при проектировании системы.

**Information Expert**

Ответственность должна быть назначена тому, кто владеет максимумом необходимой информации для исполнения.
Методы для выполнения действий стоит размещать ближе к информации, над которой эти действия проводятся.


**Creator**

Суть создателя в том, чтобы создавать другие объекты и соблюдать ряд условий:

Класс B должен создавать экземпляры класса A если выполняется одно из следующих условий в порядке важности:
- B агрегирует или содержит A.
- B использует объекты A.
- B обладает данными для инициализации экземпляров A.

```php
class Cart // B
{
    private array $items = [];
 
    public function addItem(string $name, int $amount)
    {
        $this->items[] = new Item($name, $amount); // A
    }
}

```

**Controller**

Контроллер служит для разделения интерфейса и логики. Контроллер отвечает за обработку запросов и решает кому делегировать их на выполнение.

**Low Coupling**

Мера того насколько взаимозависимы разные классы или модули. Т.е. насколько жестко один элемент связан с другими элементами, либо каким количеством данных о других элементах он обладает.

Необходимо чтобы код был слабо связан и зависел только от абстракций, а не от определенных реализаций. Вспоминаем букву D из SOLID.

**High Cohesion**

Высокое функциональное зацепление - понижаем сложность. Что это значит? Это значит, что все методы класса или все фрагменты метода должны быть сфокусированы на главной цели. В классе не должно быть ничего "лишнего". Класс не должен выполнять больших объемов работ, он не должен выполнять разнородных функций, он не должен нести на себе разных обязанностей. Ничего не напоминает? Да это буква S из SOLID.

Нарушение принципа:
```php
// Lowest cohesion
final class DataProvider
{
    public function getItemsFromDatabase()
    {
        // ...
    }
 
    public function getItemsFromAPI()
    {
        // ...
    }
}
```

**Pure Fabrication**

Суть в выдуманном объекте, который уменьшает связанность и повышает зацепление. В качестве аналога можно привести шаблон Service.

К примеру, есть объект Customer и следуя шаблону Information Expert вы наделили его логикой. Как вы реализуете сохранение Customera в БД? Так вот следуя Pure Fabrication принципу, мы создадим Сервис или репозиторий который будет доставать и сохранять такой объект в базу данных.



**Indirection**

Как определить ответственность объекта и избежать сильной связанности между объектами, даже если один класс нуждается в функционале (сервисах), который предоставляет другой класс? Решение: возложите ответственность на промежуточный объект, чтобы он осуществлял связь между другими компонентами или службами, чтобы они не были напрямую связаны.

```php
final class Item
{
    public function save()
    {
        (new ItemStorage())->save($this);
    }    
}
 
final class ItemStorage // Посредник
{
    public function save(Item $item)
    {
        (new DatabaseStorage())->save($item);
    }
}
 
final class DatabaseStorage
{
    public function save($object)
    {
        // Логика сохранения в базу
    }
}
```


**Polymorphism**

Полиморфизм позволяет реализовывать одноименные публичные методы, позволяя различным классам выполнять различные действия при одном и том же вызове. То есть объекты классов Square и Circle могут отображаться(реализовывать метод render) по-разному несмотря не то, что они оба подклассы Shape, метод render определен в Shape. (Overriding).

Принцип полиморфизма является основополагающим в ООП.



**Protected Variations**

Одним из наиболее важных показателей качества кода является простота изменений. Как архитекторы и программисты, мы должны быть готовы к постоянно меняющимся требованиям.

Для выполнения этого принципа нужно определить возможные точки нестабильности, изменений. Распределить обязанности так, чтобы обеспечить устойчивый интерфейс (контракт). То есть скрыть детали реализации за интерфейсом. 

Например, поступило требование заменить SMS-шлюз на другой. Если вы применяли этот принцип (или принцип Dependency Inversion), то вы заранее позаботились о том, чтобы ваш класс принимал зависимость в виде интерфейса SMSSenderInterface. Это позволяет при смене шлюза не менять ни строчки кода кроме той части, где определяется выбор конкретной реализации.




**[⬆ вернуться к началу](#содержание)**


### Что такое TDD?
TDD - Test Driven Development - методология разработки через тестирование.
- написать тесты для новой функциональности, которую предполагается добавить в проект
- запустить тесты и убедиться что они не проходят
- написать код новой функциональности, который должен пройти тесты
- запустить тесты и убедиться что они проходят
- выполнить рефакторинг при необходимости
- перезапустить тесты и убедиться что они все еще проходят

**[⬆ вернуться к началу](#содержание)**


### Представим ситуацию, в которой нам нужно вызвать частный метод. Как это сделать?

Для вызова частного метода в PHP классе можно использовать рефлексию. Сначала необходимо получить объект класса с помощью оператора new или других методов. Затем можно использовать класс ReflectionClass для получения информации о классе, включая список его методов. Для вызова частного метода необходимо получить объект ReflectionMethod, который представляет этот метод, и установить его доступность с помощью метода setAccessible(). После этого можно вызвать метод с помощью функции call_user_func(). Например, если у нас есть класс MyClass с частным методом privateMethod(), мы можем вызвать его следующим образом:

```php
$myObject = new MyClass();
$reflectionClass = new ReflectionClass($myObject);
$reflectionMethod = $reflectionClass->getMethod('privateMethod');
$reflectionMethod->setAccessible(true);
$result = call_user_func([$myObject, $reflectionMethod->getName()]);
```

Здесь мы создаем объект MyClass, получаем информацию о его классе с помощью ReflectionClass, получаем объект ReflectionMethod для метода privateMethod(), устанавливаем его доступность и вызываем его с помощью call_user_func(), передавая объект MyClass и имя метода в качестве параметров. Результат вызова сохраняется в переменной $result.

**[⬆ вернуться к началу](#содержание)**



## Senior

### Что такое Copy-on-write?

Copy-on-write (COW) в PHP - это техника управления памятью, используемая для оптимизации работы с массивами и объектами.  Когда создаются экземпляры массивов или объектов, PHP не создает копию их содержимого. Вместо этого, PHP создает ссылку на общие данные. Если данные в экземпляре массива или объекта изменяются позже, PHP создает копию данных, чтобы их можно было изменить без влияния на другие ссылки. Это позволяет сократить количество операций копирования и оптимизировать использование памяти. Техника COW используется для экономии памяти и улучшения производительности в PHP интерпретаторе.

Copy-on-write может быть легче понять на примере кода.

```php
function modifyArray($arr) {
    $arr[0] = 1;
    // Только при изменении данных происходит копирование
    // всего массива, чтобы не повредить оригинальный массив.
    
    // Если в функции нет операций по изменению оригинального массива,
    // то копия массива не будет создаваться. 
}

// создаем массив и передаем его в функцию modifyArray()
$array = [0, 2, 4, 6];
modifyArray($array);

// выводим оригинальный массив и видим, что он не изменился
print_r($array);

```
При чтении аргумента используется общий оригинальный массив, а при модификации выделяется память для создания копии.

Главная идея copy-on-write — при копировании областей данных создавать реальную копию только когда программа обращается к этим данным с целью записи.


**[⬆ вернуться к началу](#содержание)**

### Что такое CQRS?

CQRS (Command Query Responsibility Segregation) - это подход к проектированию системы, который разделяет операции чтения и записи данных в разные модели. Это позволяет оптимизировать работу с данными, уменьшить нагрузку на базу данных и улучшить производительность системы.


**[⬆ вернуться к началу](#содержание)**

### Что такое cohesion и coupling?

Cohesion (сцепление) и coupling (связность) - это два понятия, которые используются в объектно-ориентированном программировании для описания качества архитектуры программного обеспечения.

Cohesion (сцепление) - это мера того, насколько сильно связаны элементы внутри модуля. Высокое сцепление означает, что элементы внутри модуля тесно связаны друг с другом и выполняют одну задачу. Низкое сцепление означает, что элементы внутри модуля слабо связаны друг с другом и выполняют разные задачи.

Coupling (связность) - это мера того, насколько сильно связаны различные модули в системе. Высокая связность означает, что модули тесно связаны друг с другом и зависят друг от друга. Низкая связность означает, что модули слабо связаны друг с другом и могут работать независимо.

Высокое сцепление и низкая связность являются желательными качествами архитектуры программного обеспечения, так как они обеспечивают лучшую модульность, повторное использование кода и удобство тестирования.


**[⬆ вернуться к началу](#содержание)**

### Чем отличается Dependency Injection от Service Locator?

Dependency Injection (DI) и Service Locator (SL) - это два подхода к управлению зависимостями в приложениях. Они оба позволяют управлять объектами, которые требуются для выполнения задачи, но работают по-разному.

DI - это процесс внедрения зависимостей в объекты во время создания. Он предполагает, что объекты не должны знать о том, как создавать свои зависимости, а должны получать их извне. DI позволяет легко заменять зависимости и тестировать объекты с помощью mock-объектов.

SL - это паттерн проектирования, который предоставляет централизованное место для поиска и получения зависимостей. Объекты запрашивают нужные им зависимости из контейнера через специальный интерфейс (Service Locator). SL обычно используется для управления сложными зависимостями, которые могут быть изменены во время выполнения приложения.

Основное отличие между DI и SL заключается в том, что DI предоставляет зависимости объектам во время создания, а SL предоставляет зависимости объектам во время выполнения.

В SL зависимости запрашиваются явно, например Yii::$app->get('logger');

В целом, Dependency Injection считается лучшим подходом, поскольку он является более прозрачным и модульным, что упрощает тестирование и поддержку кода.


**[⬆ вернуться к началу](#содержание)**


### Что такое антипаттерны? Приведите несколько примеров.

Антипатерны - это повторяющиеся ошибки в проектировании и разработке программного обеспечения, которые приводят к низкому качеству кода, трудностям в поддержке и расширении приложения, а также к дополнительным затратам на разработку.

1. **Big Ball of Mud** (Большой ком из грязи) - это антипаттерн, который описывает приложение, не имеющее четкой структуры и организации кода. В результате код становится трудным для понимания и изменения.

2. **God Object** (Божественный объект) - это объект, который выполняет слишком много задач и содержит слишком много функциональности. Это приводит к зависимости между различными частями кода и затрудняет тестирование и поддержку.

3. **Spaghetti Code** (Код-спагетти) - это код, который содержит множество взаимосвязанных частей, что приводит к трудностям в понимании и изменении кода. Это может быть вызвано отсутствием структуры и организации кода или неправильным использованием паттернов проектирования.

4. **Magic Number** (Магическое число) - это использование чисел в коде без объяснения их значения. Это затрудняет понимание кода и может привести к ошибкам при изменении кода.

5. **Copy-Paste Programming** (Программирование копированием и вставкой) - это практика копирования и вставки кода из одной части приложения в другую, вместо того, чтобы создавать повторно используемые модули. Это приводит к дублированию кода и увеличивает сложность поддержки кода.


**[⬆ вернуться к началу](#содержание)**



### По какому принципу будете выбирать архитектуру для своей будущей программы?

При выборе архитектуры для своей будущей программы, я бы учитывал следующие принципы и критерии:

- Функциональность программы и ее основные требования. Архитектура должна соответствовать функциональным требованиям программы и включать необходимые компоненты и сервисы.

- Расширяемость и гибкость. Архитектура должна быть гибкой и расширяемой, чтобы можно было вносить изменения и дополнения в программу в будущем, при этом не нарушая стабильность и работоспособность системы.

- Разделение ответственности (separation of concerns). Архитектура должна обладать ясным разделением ответственности между различными компонентами и слоями системы, чтобы каждый компонент выполнял свою задачу и не заботился о других.

- Производительность и масштабируемость. Архитектура должна обеспечивать высокую производительность и масштабируемость системы.

- Безопасность. Архитектура должна обеспечивать безопасность приложения и защищать данные пользователей.

- Сообщество и поддержка. При выборе архитектуры следует учитывать наличие сообщества участников и ресурсов, которые обеспечивают поддержку и развитие данной архитектуры.

- Опыт команды разработчиков. Наконец, при выборе архитектуры следует учитывать опыт и знания команды разработчиков, чтобы выбрать оптимальное решение

**[⬆ вернуться к началу](#содержание)**


### С какими видами архитектуры приложений сталкивались?

Я встречал различные виды архитектур приложений в зависимости от конкретной задачи и требований к проекту. Некоторые из них, которые я использовал или изучал, включают:

Layered architecture (Многослойная архитектура) - разбиение приложения на слои функциональности для обеспечения лучшей организации кода и уменьшения зависимости между компонентами.
(слой представления, слой бизнес-логики, слой передачи данных)

Service-Oriented Architecture (SOA) (Ориентированная на службы архитектура) - подражание интерфейсами удаленным вызовам (веб-службам), с целью разделения приложения на меньшие, более управляемые части.

Model-View-Controller (MVC) (Модель-Представление-Контроллер) - структурирование пользовательского интерфейса в форме 3 логически связанных компонентов.

Microservices Architecture (Микросервисная архитектура) - создание независимых, распределенных сервисов для каждой отдельной функциональности, обеспечения лучшей масштабируемости и гибкости.

Event-Driven Architecture (EDA) (Архитектура на основе событий) - реализация обмена данными на основе асинхронных сообщений и оповещений.

Domain-Driven Design (DDD) (Проектирование, ориентированное на домен) - структурирование приложения, ориентированное на бизнес-логику и управление данными.

**[⬆ вернуться к началу](#содержание)**



### Как вы понимаете Exception flow в контексте PHP.

Exception flow (поток исключений) - это последовательность возникновения и обработки исключений в PHP.

Когда в PHP возникает исключение, оно выдается в форме объекта, содержащего сообщение об ошибке, тип исключения и другую информацию. Затем исключение может быть перехвачено с помощью блока try-catch, где можно выполнить необходимые операции для обработки ошибки. Если исключение не перехватывается в текущем блоке try-catch, оно передается выше по стеку вызовов до тех пор, пока не будет обработано или не достигнет верхнего уровня программы, где скрипт будет завершен.

Проблемы, связанные с исключениями в PHP, могут включать неуместную обработку исключений, неявное игнорирование исключений и дублирование исключений. Для устранения этих проблем следует следовать основным принципам обработки исключений в PHP, таким как выбор правильных типов исключений для конкретных ошибок, использование блоков try-catch только там, где это действительно необходимо, и убеждение в том, что исключения обрабатываются и возвращаются в правильной форме.


**[⬆ вернуться к началу](#содержание)**
